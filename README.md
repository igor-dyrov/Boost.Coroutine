# Boost.Coroutine
С помощью [Boost.Coroutine](http://www.boost.org/libs/coroutine) стало возможным использовать сопрограммы в C++.
Сопрограммы - функция в других языках программирования, которые используют ключевое слово ***yield*** для сопрограмм.
В этих языках ***yield*** может использоваться как ***return***.
Когда используется ***yield***, функция запоминает положение, и если функция вызывается снова,
выполнение продолжается с того же места.

В C++ не определено ключевое слово ***yield***. C помощью Boost.Coroutine можно выйти из функции и
продолжить позже с того же места. Boost.Asio также использует выгоды
Boost.Coroutine.

Есть две версии Boost.Coroutine. Эта глава показывает вторую версию, которая является актуальной.
Эта версия была доступна начиная с Boost 1.55.0 и пришла на замену первой.

`Пример 51.1. Использование сопрограмм.`
<a name="example511"></a>
```c++
#include <boost/coroutine/all.hpp>
#include <iostream>

using namespace boost::coroutines;

void cooperative(coroutine<void>::push_type &sink)
{
  std::cout << "Hello";
  sink();
  std::cout << "world";
}

int main()
{
  coroutine<void>::pull_type source{cooperative};
  std::cout << ", ";
  source();
  std::cout << "!\n";
}
```

[Пример 51.1](#example511) определяет функцию, ***cooperative()***, которую вызывают из ***main()*** как сопрограмму. ***cooperative()***
возвращается к ***main()***, не отработав до конца и вызывается во второй раз.
На втором вызове функция продолжает работу с того места, где закончила в прошлый раз.

Чтобы использовать ***cooperative()*** как сопрограмму, надо использовать типы ***pull_type*** и ***push_type***.
Эти типы определены в ***boost::coroutines::coroutine***, которая является шаблоном,
инстанцированном с ***void*** в [Примере 51.1](example511).

