# Boost.Coroutine
С помощью [Boost.Coroutine](http://www.boost.org/libs/coroutine) стало возможным использовать сопрограммы в C++.
Сопрограммы - функция в других языках программирования, которые используют ключевое слово ***yield*** для сопрограмм.
В этих языках ***yield*** может использоваться как ***return***.
Когда используется ***yield***, функция запоминает положение, и если функция вызывается снова,
выполнение продолжается с того же места.

В C++ не определено ключевое слово ***yield***. C помощью Boost.Coroutine можно выйти из функции и
продолжить позже с того же места. Boost.Asio также использует выгоды
Boost.Coroutine.

Есть две версии Boost.Coroutine. Эта глава показывает вторую версию, которая является актуальной.
Эта версия была доступна начиная с Boost 1.55.0 и пришла на замену первой.

`Пример 51.1. Использование сопрограмм.`
<a name="example511"></a>
```c++
#include <boost/coroutine/all.hpp>
#include <iostream>

using namespace boost::coroutines;

void cooperative(coroutine<void>::push_type &sink)
{
  std::cout << "Hello";
  sink();
  std::cout << "world";
}

int main()
{
  coroutine<void>::pull_type source{cooperative};
  std::cout << ", ";
  source();
  std::cout << "!\n";
}
```

[Пример 51.1](#example511) определяет функцию, ***cooperative()***, которую вызывают из ***main()*** как сопрограмму. ***cooperative()***
возвращается к ***main()***, не отработав до конца и вызывается во второй раз.
На втором вызове функция продолжает работу с того места, где закончила в прошлый раз.

Чтобы использовать ***cooperative()*** как сопрограмму, надо использовать типы ***pull_type*** и ***push_type***.
Эти типы определены в ***boost::coroutines::coroutine***, которая является шаблоном,
инстанцированном с ***void*** в [Примере 51.1](example511).

Чтобы использовать сопрограммы, Вам нужны типы ***pull_type*** и ***push_type***. Один из этих типов будет использоваться, чтобы создать объект, который будет инициализирован с функцией, использующейся в качестве сопрограммы. Другой тип будет первым параметром функции сопрограммы.

[Пример 51.1](example511) создает объект, названный ***source***, типа ***pull_type*** в функции ***main()***. ***cooperative()*** передается в конструктор. ***push_type*** используется в качестве единственного параметра в ***cooperative()***.

Когда создается ***source***, функция ***cooperative()***, которая передан в конструктор, сразу вызывается как сопрограмма. Это происходит, потому что источник определен как ***pull_type***. Если бы источник был типа ***push_type***, конструктор не вызвал бы ***cooperative()*** как сопрограмму.

***cooperative()*** пишет ***Hello*** в стандартный поток вывода. После этого функция получает доступ к ***sink***, как если бы это была функция. Это возможно потому что ***push_type*** перегружает ***operator()***. В то время как ***source*** в ***main()*** представляет сопрограмму ***cooperative()***, ***sink*** представляет функцию ***main()*** в ***cooperative()***. Вызов ***sink*** заставляет ***cooperative()*** покинуть функцию, и ***main()*** продолжается с того места, где был вызван ***cooperative()*** и пишет запятую в стандартный поток вывода.

